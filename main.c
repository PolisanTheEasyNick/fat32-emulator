#include <stdio.h>
#include <stdlib.h>
#include <stdint.h> //for int32_t
#include <string.h> //memset
#include <time.h>

// https://www.pjrc.com/tech/8051/ide/fat32.html

uint16_t BPB_BytesPerSector = 0; //Bytes Per Sector, must be 512
uint8_t BPB_SecPerCluster = 0; //Sectors Per Cluster
uint16_t BPB_RsvdSecCnt = 0; //Number of Reserved Sectors, usually 0x20
uint8_t BPB_NumFATs = 0; //Number of FAT's, must be 2
uint8_t BPB_Media = 0; //0xF8 standart for non-removable media, 0xF0 for removable
uint32_t BPB_TotSec32 = 0; //count of sectors on the volume

//FAT32-only fields
uint32_t BPB_FATSz32 = 0; //Sectors Per FAT
uint16_t BPB_ExtFlags = 0; //must be 0 if mirroring is disabled
uint16_t BPB_FSVer = 0; //must be 0?
uint32_t BPB_RootClus = 0; //Root Directory First Cluster
uint16_t BPB_FSInfo = 0; //usually 1
uint16_t BPB_BkBootSec = 0; //sector num of a copy of the Boot Record, usually 6
uint8_t BS_DrvNum = 0; // int 0x13 drive number (e.g, 0x80), offset 64 decimal for FAT32
uint8_t BS_BootSig = 0; // Extended boot signature, offset 66
uint32_t BS_VolID = 0; // Volume serial number, simply generated by combinint date and time into a 32-bit value
unsigned char BS_VolLab[11] = "NO NAME    "; // volume label, "NO NAME" where no volume label
unsigned char BS_FilSysType[8] = "FAT32   ";

//File attributes
enum {
    ATTR_READ_ONLY = 0x01,
    ATTR_HIDDEN = 0x02,
    ATTR_SYSTEM = 0x04,
    ATTR_VOLUME_ID = 0x08,
    ATTR_DIRECTORY = 0x10,
    ATTR_ARCHIVE = 0x20,
    ATTR_LONG_NAME = ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID
};

struct DirectoryFAT32 {
    unsigned char DIR_NAME[11]; //Short Name
    uint8_t DIR_ATTR; //File attributes
    uint8_t DIR_NTRes; //Reserved for use by Windows NT, must be 0
    uint8_t DIR_CrtTimeTenth; //Millisecond stamp at file creation time, tenths of a second, 0-199.
    uint16_t DIR_CrtTime; //Time file was created;
    uint16_t DIR_CrtDate; //Date file was created;
    uint16_t DIR_LstAccDate; //Last access date, when write must be same as DIR_WrtTime
    uint16_t DIR_FstClusHI; //High word of this entry's first cluster number
    uint16_t DIR_WrtTime; //Time of last write
    uint16_t DIR_WrtDate; //Date of last write
    uint16_t DIR_FstClusLO; //Low word of this entry's first cluster number
    uint32_t DIR_FileSize; //32-bit DWORD holding file size in bytes

};

int init(uint8_t* disk) {

    BPB_BytesPerSector = 0;
    BPB_SecPerCluster = 0;
    BPB_RsvdSecCnt = 0;
    BPB_NumFATs = 0;
    //BPB_Media = 0;
    BPB_TotSec32 = 0;
    BPB_FATSz32 = 0;
    BPB_ExtFlags = 0;
    BPB_FSVer = 0;
    BPB_RootClus = 0;
    BPB_FSInfo = 0;
    BPB_BkBootSec = 0;
    BS_DrvNum = 0;
    BS_BootSig = 0;

    //TODO: read and print all FAT32 information??

    BPB_BytesPerSector |= *(disk + 0x0B + 1);
    BPB_BytesPerSector <<= 8;
    BPB_BytesPerSector |= *(disk + 0x0B);
    printf("Bytes Per Sector: %d\n", BPB_BytesPerSector);
    if(BPB_BytesPerSector != 512) {
        printf("Bytes Per Sector NOT 512! Aborting.\n");
        return -1;
    }

    BPB_SecPerCluster |= *(disk + 0x0D);
    printf("Sectors Per Cluster: %d\n", BPB_SecPerCluster);

    BPB_RsvdSecCnt |= *(disk + 0x0E + 1);
    BPB_RsvdSecCnt <<= 8;
    BPB_RsvdSecCnt |= *(disk + 0x0E);
    printf("Number of Reserved Sectors: %d\n", BPB_RsvdSecCnt);

    BPB_NumFATs |= *(disk + 0x10);
    printf("Number of FATs: %d\n", BPB_NumFATs);
    if(BPB_NumFATs != 2) {
        printf("Number of FATs NOT 2! Aborting.\n");
        return -2;
    }


    BPB_FATSz32 |= *(disk + 0x24 + 3);
    BPB_FATSz32 <<= 8;
    BPB_FATSz32 |= *(disk + 0x24 + 2);
    BPB_FATSz32 <<= 8;
    BPB_FATSz32 |= *(disk + 0x24 + 1);
    BPB_FATSz32 <<= 8;
    BPB_FATSz32 |= *(disk + 0x24);
    printf("Sectors Per FAT: %d\n", BPB_FATSz32);

    BPB_RootClus |= *(disk + 0x2C + 3);
    BPB_RootClus <<= 8;
    BPB_RootClus |= *(disk + 0x2C + 2);
    BPB_RootClus <<= 8;
    BPB_RootClus |= *(disk + 0x2C + 1);
    BPB_RootClus <<= 8;
    BPB_RootClus |= *(disk + 0x2C);
    printf("Root Directory First Cluster: 0x%x\n", BPB_RootClus);

    unsigned short signature = 0;
    signature |= *(disk + 0x1FE);
    signature <<= 8;
    signature |= *(disk + 0x1FE + 1);
    printf("Signature: 0x%x\n", signature);
    if(signature != 0x55AA) {
        printf("Signature NOT 0x55AA! Aborting.\n");
        return -3;
    }

    printf("MBR check-up successfully completed!\n");
    return 0;
}

void writeMBR(uint8_t *disk) {
    //Dummy jump instruction, BS_jmpBoot
    *disk = 0xEB;
    *(disk+1) = 0x58;
    *(disk+2) = 0x90;

    //OEM name, BS_OEMName
    char oem[] = {'f', 'a', 't', '-', 'e', 'm', 'u', 'l'};
    memcpy(disk+0x03, oem, 8);

    //BIOS Parameter Block (BPB)
    *((uint16_t*)(disk+0xB)) = BPB_BytesPerSector;
    *(disk+0xD) = BPB_SecPerCluster;
    *((uint16_t*)(disk+0xE)) = BPB_RsvdSecCnt;
    *(disk+0x10) = BPB_NumFATs;
    *(disk+21) = BPB_Media;
    *((uint32_t*)(disk+0x24)) = BPB_FATSz32;
    *((uint16_t*)(disk+40)) = BPB_ExtFlags;
    *((uint16_t*)(disk+42)) = BPB_FSVer;
    *((uint32_t*)(disk+0x2C)) = BPB_RootClus;
    *((uint16_t*)(disk+48)) = BPB_FSInfo;
    *((uint16_t*)(disk+50)) = BPB_BkBootSec;
    *((uint8_t*)(disk+52)) = BS_DrvNum;
    *((uint8_t*)(disk+66)) = BS_BootSig;
    *((uint32_t*)(disk+66)) = BS_VolID;
    memcpy(disk+71, BS_VolLab, 11);
    memcpy(disk+82, BS_FilSysType, 8);


    *((uint16_t*)(disk+0x1FE)) = 0xAA55;
}

void writeFSInfSector(uint8_t *disk) {
    uint8_t *FSInfo_start = disk+0x200;
    //RRaA sector signature, FSI_LeadSig
    *(FSInfo_start) = 0x52;
    *(FSInfo_start+1) = 0x52;
    *(FSInfo_start+2) = 0x61;
    *(FSInfo_start+3) = 0x41;

    //bytes 4 -> 484 (0x1E4) - FSI_Reserved1

    //rrAa sector signature, FSI_StrucSig
    *(FSInfo_start+0x1E4) = 0x72;
    *(FSInfo_start+0x1E4+1) = 0x72;
    *(FSInfo_start+0x1E4+2) = 0x41;
    *(FSInfo_start+0x1E4+3) = 0x61;

    //last known number of free data clusters on the volume, FSI_Free_Count
    *(FSInfo_start+0x1E8) = 0x69;
    *(FSInfo_start+0x1E8+1) = 0x9D;
    *(FSInfo_start+0x1E8+2) = 0x00;
    *(FSInfo_start+0x1E8+3) = 0x00;

    //number of most recently known to be allocated data cluster, FSI_Nxt_Free
    *(FSInfo_start+0x1EC) = 0x02;
    *(FSInfo_start+0x1EC+1) = 0x00;
    *(FSInfo_start+0x1EC+2) = 0x00;
    *(FSInfo_start+0x1EC+3) = 0x00;

    //bytes 496 - 508 (0x1FC) - FSI_Reserved2

    //FS information sector signature
    *(FSInfo_start+0x1FC) = 0x00;
    *(FSInfo_start+0x1FC+1) = 0x00;
    *(FSInfo_start+0x1FC+2) = 0x55;
    *(FSInfo_start+0x1FC+3) = 0xAA;
}

void format(uint8_t* disk, unsigned int size) {

    BPB_BytesPerSector = 512;
    BPB_SecPerCluster = 1;
    BPB_RsvdSecCnt = 32; //typical for FAT32
    BPB_NumFATs = 2;
    BPB_Media = 0xF8;

    //FAT32-only fields
    BPB_TotSec32 = size / BPB_BytesPerSector;
    uint32_t n_clusters = (BPB_TotSec32 - BPB_RsvdSecCnt) / BPB_SecPerCluster;
    BPB_FATSz32 = (((n_clusters + 2) * 4) + BPB_BytesPerSector - 1) / BPB_BytesPerSector;
    BPB_ExtFlags = 0x04; //without mirroring, fat0 is active
    BPB_FSVer = 0; //0:0 version
    BPB_RootClus = 2;
    BPB_FSInfo = 1;
    BPB_BkBootSec = 6;
    BS_DrvNum = 0x80;
    BS_BootSig = 0x29;
    BS_VolID = (uint32_t)time(NULL);
    memcpy(BS_VolLab, "NO NAME    ", sizeof(11));
    memcpy(BS_FilSysType, "FAT32   ", sizeof(8));

    memset(disk, 0, 20480);

    writeMBR(disk); //Master Boot Record
    writeFSInfSector(disk); //File System Information Sector


    //Backup MBR at sector 6
    //Writing MBR, BPB_BkBootSec
    writeMBR(disk + BPB_BytesPerSector * BPB_BkBootSec);
    writeFSInfSector(disk + BPB_BytesPerSector * BPB_BkBootSec);  //A copy of the FSInfo sector is also there

    //root?
    *(disk+0x4000) = 0xF8;
    *(disk+0x4000+1) = 0xFF;
    *(disk+0x4000+2) = 0xFF;
    *(disk+0x4000+3) = 0x0F;
    *(disk+0x4000+4) = 0xFF;
    *(disk+0x4000+5) = 0xFF;
    *(disk+0x4000+6) = 0xFF;
    *(disk+0x4000+7) = 0x0F;
    *(disk+0x4000+8) = 0xF8;
    *(disk+0x4000+9) = 0xFF;
    *(disk+0x4000+10) = 0xFF;
    *(disk+0x4000+11) = 0x0F;
}

int main()
{
    FILE *image = fopen("/home/ob3r0n/fat32.disk", "wb");
    if(!image) {
        perror("Error opening image!\n");
        //create then..
        return -1;
    }
    printf("Image opened successfully!\n");

    uint8_t *disk = malloc(20971520);

    format(disk, 20971520);
    fwrite(disk, 1, 20971520, image);
    fclose(image);

    image = fopen("/home/ob3r0n/fat32.disk", "rb");
    if(!image) {
        perror("Error opening image:");
        //create then..
        free(disk);
        return -1;
    }

    if(fread(disk, 1, 20971520, image) != 20971520) {
        perror("Error reading image: ");
        return -1;
    }
    printf("Image readed successfully!\n");

    init(disk);
    free(disk);
    return 0;
}
